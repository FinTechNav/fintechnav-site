<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fiska Checkout Demo | FinTechNav</title>
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon-192.png" sizes="192x192" />
    <link rel="apple-touch-icon" href="/favicon-192.png" />
    <link
      href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;500;600;700&family=Poiret+One&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --color-primary: #c9a15f;
        --color-primary-hover: #b89050;
        --color-background: #1a1a1a;
        --color-text: #e0e0e0;
        --color-text-light: #a0a0a0;
        --color-border: #3a3a3a;
        --color-error: #ff6b6b;
        --color-success: #6bff9e;
        --font-family-heading: 'Poiret One', cursive;
        --font-family-body: 'Cormorant Garamond', serif;
        --border-radius: 6px;
        --box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      }

      body {
        font-family: var(--font-family-body);
        line-height: 1.7;
        color: var(--color-text);
        background-color: var(--color-background);
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-size: 1.1rem;
      }

      .container {
        width: 100%;
        max-width: 800px;
        margin: 40px auto;
        padding: 30px;
        box-shadow: var(--box-shadow);
        border-radius: var(--border-radius);
        background-color: #252525;
        border: 1px solid var(--color-border);
        transition: filter 0.3s ease;
      }

      .container.blurred {
        filter: blur(5px);
        pointer-events: none; /* Prevent interaction with blurred content */
      }

      h1,
      h2,
      h3 {
        font-family: var(--font-family-heading);
        color: var(--color-text);
        margin-top: 0;
        font-weight: 400;
        letter-spacing: 0.03em;
      }

      h2 {
        font-size: 2.5rem;
        margin-bottom: 20px;
        border-bottom: 1px solid var(--color-border);
        padding-bottom: 10px;
        color: var(--color-primary);
      }

      .section {
        margin-bottom: 30px;
      }

      .order-summary {
        background-color: #3a3a3a;
        padding: 20px;
        border-radius: var(--border-radius);
        margin-bottom: 30px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      .order-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
      }

      .order-total {
        font-weight: bold;
        font-size: 1.2rem;
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid var(--color-border);
      }

      .form-group {
        margin-bottom: 15px;
      }

      .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
        color: var(--color-text);
      }

      .payment-method {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        padding: 10px;
        background-color: #3a3a3a;
        border-radius: var(--border-radius);
        transition: background-color 0.3s ease;
      }

      .payment-method:hover {
        background-color: #444;
      }

      .payment-method input[type='radio'] {
        margin-right: 15px;
      }

      .payment-method-info {
        flex-grow: 1;
      }

      .add-new-card {
        display: inline-block;
        margin-top: 10px;
        color: var(--color-primary);
        text-decoration: none;
        font-weight: 500;
        cursor: pointer;
      }

      .add-new-card:hover {
        color: var(--color-primary-hover);
        text-decoration: underline;
      }

      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7); /* Darkened background for better focus */
        z-index: 100;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(3px); /* Additional blur effect for background */
        scrollbar-width: none !important; /* Firefox */
        -ms-overflow-style: none !important; /* IE and Edge */
      }

      .modal-overlay::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(26, 26, 26, 0.8); /* Site background with opacity */
        z-index: -1;
      }

      .modal-overlay::-webkit-scrollbar {
        display: none !important;
        width: 0 !important;
      }

      .modal {
        background-color: transparent !important; /* Remove background */
        border: none !important; /* Remove border */
        padding: 0 !important; /* Remove padding */
        box-shadow: none !important; /* Remove shadow */
        width: 100%;
        max-width: 620px; /* Increased width to ensure no horizontal scrollbar */
        height: 800px; /* Further increased height */
        position: relative;
        overflow: visible; /* Ensure any overflow is visible */
      }

      /* Extra background coverage to hide any borders */
      .modal::before {
        content: '';
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        background-color: #1a1a1a; /* Match page background */
        z-index: -1;
      }

      /* Add specific side covers to mask blue borders */
      .modal::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 20px; /* Width of the cover */
        right: -20px; /* Position it outside the modal */
        background-color: #1a1a1a; /* Match page background */
        z-index: 150;
      }

      /* Add left side cover */
      .side-cover-left {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 20px;
        left: -20px;
        background-color: #1a1a1a;
        z-index: 150;
      }

      /* Add right side cover */
      .side-cover-right {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 20px;
        right: -20px;
        background-color: #1a1a1a;
        z-index: 150;
      }

      #paymentFormContainer {
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        height: 100%;
        position: relative;
        overflow: hidden !important;
        border: none !important;
        outline: none !important;
      }

      .iframe-container {
        width: 100%;
        height: 100%;
        border: none !important;
        outline: none !important;
        scrollbar-width: none !important; /* Firefox */
        -ms-overflow-style: none !important; /* IE and Edge */
        box-shadow: none !important;
        background-color: transparent !important;
      }

      /* Hide scrollbar for Chrome, Safari and Opera */
      .iframe-container::-webkit-scrollbar {
        display: none !important;
        width: 0 !important;
      }

      /* Close button */
      .modal-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 36px; /* Increased size */
        height: 36px; /* Increased size */
        background-color: #c9a15f; /* Solid color instead of transparent */
        color: #1a1a1a; /* Dark text on light background for contrast */
        border: 2px solid white; /* Add white border for extra visibility */
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 9999; /* Very high z-index to guarantee it's on top */
        font-size: 24px;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5); /* Stronger shadow */
        opacity: 1 !important; /* Force opacity to 100% */
        pointer-events: auto !important; /* Ensure it can be clicked */
      }

      .modal-close-btn:hover {
        background-color: white;
        color: #c9a15f;
        transform: scale(1.1);
      }

      .btn {
        display: inline-block;
        background-color: var(--color-primary);
        color: white;
        padding: 12px 25px;
        border: none;
        border-radius: var(--border-radius);
        font-size: 1rem;
        font-weight: 500;
        cursor: pointer;
        text-decoration: none;
        text-align: center;
        transition: background-color 0.3s ease;
        margin-right: 10px;
        margin-bottom: 10px;
      }

      .btn:hover {
        background-color: var(--color-primary-hover);
      }

      .api-key-section {
        margin-bottom: 30px;
        padding: 20px;
        background-color: #3a3a3a;
        border-radius: var(--border-radius);
        border: 1px solid var(--color-border);
      }

      .api-key-input {
        width: 100%;
        padding: 10px;
        border: 1px solid var(--color-border);
        border-radius: var(--border-radius);
        margin-bottom: 10px;
        background-color: #2a2a2a;
        color: var(--color-text);
        font-family: var(--font-family-body);
      }

      .alert {
        padding: 10px 15px;
        border-radius: var(--border-radius);
        margin-bottom: 15px;
        display: none;
      }

      .alert-error {
        background-color: rgba(255, 107, 107, 0.2);
        border: 1px solid rgba(255, 107, 107, 0.4);
        color: var(--color-error);
      }

      .alert-success {
        background-color: rgba(107, 255, 158, 0.2);
        border: 1px solid rgba(107, 255, 158, 0.4);
        color: var(--color-success);
      }

      .spinner {
        display: none;
        width: 40px;
        height: 40px;
        margin: 20px auto;
        border: 4px solid rgba(201, 161, 95, 0.1);
        border-radius: 50%;
        border-top-color: var(--color-primary);
        animation: spin 1s ease-in-out infinite;
      }

      /* Escape key instruction */
      .escape-instruction {
        position: absolute;
        bottom: 15px;
        left: 0;
        right: 0;
        text-align: center;
        color: var(--color-text-light);
        font-size: 0.9rem;
        z-index: 101;
      }

      /* Token cards section */
      .token-card {
        background-color: #3a3a3a;
        border-radius: var(--border-radius);
        padding: 15px;
        margin-bottom: 10px;
        border-left: 3px solid var(--color-primary);
        transition: all 0.3s ease;
      }

      .token-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .no-tokens-message {
        padding: 15px;
        background-color: rgba(201, 161, 95, 0.1);
        border-radius: var(--border-radius);
        text-align: center;
        color: var(--color-text-light);
      }

      .button-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .divider {
        height: 1px;
        background-color: var(--color-border);
        margin: 20px 0;
      }

      .expanded-section {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .expanded-section.active {
        max-height: 1000px;
      }

      .toggle-button {
        background: none;
        border: none;
        color: var(--color-primary);
        cursor: pointer;
        font-family: var(--font-family-body);
        font-size: 1rem;
        text-decoration: underline;
        padding: 0;
        margin-bottom: 10px;
      }

      .toggle-button:hover {
        color: var(--color-primary-hover);
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container" id="mainContainer">
      <div class="api-key-section">
        <h3>API Configuration</h3>
        <div class="form-group">
          <label for="apiKey">API Key:</label>
          <input
            type="text"
            id="apiKey"
            class="api-key-input"
            placeholder="Paste your API key here"
          />
        </div>
        <div class="form-group">
          <label for="paymentMethodId">Payment Method ID (optional):</label>
          <input
            type="text"
            id="paymentMethodId"
            class="api-key-input"
            placeholder="Enter payment method ID or leave blank if you only have one payment method ID"
          />
        </div>

        <!-- Toggle for additional fields -->
        <button type="button" id="toggleAdditionalFields" class="toggle-button">
          Show Additional Configuration Fields
        </button>

        <!-- Additional API configuration fields (expandable) -->
        <div id="additionalFields" class="expanded-section">
          <div class="form-group">
            <label for="amount">Amount (in cents):</label>
            <input
              type="text"
              id="amount"
              class="api-key-input"
              placeholder="e.g., 7273 for $72.73"
            />
          </div>

          <div class="form-group">
            <label for="amountGoodsAndServices">Amount Goods and Services (in cents):</label>
            <input
              type="text"
              id="amountGoodsAndServices"
              class="api-key-input"
              placeholder="e.g., 6773 for $67.73"
            />
          </div>

          <div class="form-group">
            <label for="tax">Tax Amount (in cents):</label>
            <input type="text" id="tax" class="api-key-input" placeholder="e.g., 500 for $5.00" />
          </div>

          <div class="form-group">
            <label for="cashBack">Cash Back Amount (in cents):</label>
            <input
              type="text"
              id="cashBack"
              class="api-key-input"
              placeholder="e.g., 0 for $0.00"
            />
          </div>

          <div class="form-group">
            <label for="tip">Tip Amount (in cents):</label>
            <input type="text" id="tip" class="api-key-input" placeholder="e.g., 1000 for $10.00" />
          </div>

          <div class="form-group">
            <label for="invoiceNumber">Invoice Number:</label>
            <input
              type="text"
              id="invoiceNumber"
              class="api-key-input"
              placeholder="e.g., INV-12345"
            />
          </div>

          <div class="form-group">
            <label for="orderNumber">Order Number:</label>
            <input
              type="text"
              id="orderNumber"
              class="api-key-input"
              placeholder="e.g., ORD-12345"
            />
          </div>

          <div class="form-group">
            <label for="referenceId">Reference ID:</label>
            <input
              type="text"
              id="referenceId"
              class="api-key-input"
              placeholder="e.g., REF-12345"
            />
          </div>
        </div>

        <button id="saveApiKey" class="btn">Save Configuration</button>
        <div id="apiKeyStatus" class="alert"></div>
      </div>

      <div class="section order-summary">
        <h2>Order Summary</h2>
        <div class="order-item">
          <span>2022 Alderpoint Vineyard Pinot Noir (750ml)</span>
          <span>$45.00</span>
        </div>
        <div class="order-item">
          <span>Shipping (UPS Ground)</span>
          <span>$27.73</span>
        </div>
        <div class="order-item">
          <span>Tax</span>
          <span>$0.00</span>
        </div>
        <div class="order-total">
          <span>Total</span>
          <span>$72.73</span>
        </div>
      </div>

      <div class="section payment-section">
        <h2>Payment Method</h2>
        <div id="savedCardsContainer">
          <!-- Saved cards will be displayed here -->
          <div class="no-tokens-message" id="noTokensMessage">
            No saved payment methods available. You can add a new card or use stored tokens from
            webhooks.
          </div>
        </div>
        <a href="#" class="add-new-card" id="addNewCardBtn">+ ADD NEW CARD</a>
        <div style="margin-top: 10px">
          <a href="#" class="add-new-card" id="refreshTokensBtn" style="margin-left: 15px"
            >↻ Refresh Payment Methods</a
          >
          <a href="#" class="add-new-card" id="simulateTokenBtn" style="margin-left: 15px"
            >+ Simulate Token</a
          >
          <a href="#" class="add-new-card" id="simulateProductionBtn" style="margin-left: 15px"
            >🔄 Test Production Format</a
          >
        </div>
      </div>

      <div class="button-container">
        <button class="btn" id="checkoutExistingBtn">
          Complete Checkout with Selected Payment Method
        </button>
        <button class="btn" id="checkoutNewBtn">Complete Checkout with a New Card</button>
      </div>
    </div>

    <div class="modal-overlay" id="cardModal">
      <div class="modal">
        <!-- Add a close button -->
        <button class="modal-close-btn" id="closeModal">×</button>

        <!-- Side covers to hide any vertical borders -->
        <div class="side-cover-left"></div>
        <div class="side-cover-right"></div>

        <div id="paymentFormContainer">
          <div id="apiError" class="alert alert-error"></div>
          <div id="spinner" class="spinner"></div>
          <iframe
            id="paymentIframe"
            class="iframe-container"
            style="display: none"
            frameborder="0"
            allowtransparency="true"
            scrolling="no"
          ></iframe>
        </div>

        <!-- Escape key instruction -->
        <div class="escape-instruction">Press ESC to close</div>
      </div>
    </div>

    <script>
      // Local storage keys
      const API_KEY_STORAGE = 'fiska_api_key';
      const PAYMENT_METHOD_ID_STORAGE = 'fiska_payment_method_id';
      const AMOUNT_STORAGE = 'fiska_amount';
      const AMOUNT_GOODS_SERVICES_STORAGE = 'fiska_amount_goods_services'; // Add this line
      const TAX_STORAGE = 'fiska_tax';
      const CASHBACK_STORAGE = 'fiska_cashback';
      const TIP_STORAGE = 'fiska_tip';
      const INVOICE_NUMBER_STORAGE = 'fiska_invoice_number';
      const ORDER_NUMBER_STORAGE = 'fiska_order_number';
      const REFERENCE_ID_STORAGE = 'fiska_reference_id';
      const TOKEN_STORAGE = 'fiska_tokens';

      // DOM elements
      const apiKeyInput = document.getElementById('apiKey');
      const paymentMethodIdInput = document.getElementById('paymentMethodId');
      const amountInput = document.getElementById('amount');
      const amountGoodsAndServicesInput = document.getElementById('amountGoodsAndServices'); // Add this line
      const taxInput = document.getElementById('tax');
      const cashBackInput = document.getElementById('cashBack');
      const tipInput = document.getElementById('tip');
      const invoiceNumberInput = document.getElementById('invoiceNumber');
      const orderNumberInput = document.getElementById('orderNumber');
      const referenceIdInput = document.getElementById('referenceId');
      const apiKeyStatus = document.getElementById('apiKeyStatus');
      const saveApiKeyBtn = document.getElementById('saveApiKey');
      const addNewCardBtn = document.getElementById('addNewCardBtn');
      const cardModal = document.getElementById('cardModal');
      const closeModalBtn = document.getElementById('closeModal');
      const paymentIframe = document.getElementById('paymentIframe');
      const apiError = document.getElementById('apiError');
      const spinner = document.getElementById('spinner');
      const savedCardsContainer = document.getElementById('savedCardsContainer');
      const paymentFormContainer = document.getElementById('paymentFormContainer');
      const mainContainer = document.getElementById('mainContainer');
      const noTokensMessage = document.getElementById('noTokensMessage');
      const checkoutExistingBtn = document.getElementById('checkoutExistingBtn');
      const checkoutNewBtn = document.getElementById('checkoutNewBtn');
      const toggleAdditionalFieldsBtn = document.getElementById('toggleAdditionalFields');
      const additionalFieldsSection = document.getElementById('additionalFields');

      // API endpoints
      const API_BASE_URL = 'https://beta-payment-api-http.dev.ms.fiska.tech/v1';
      // Hard-coded return URL
      const RETURN_URL = 'https://fintechnav.com/payment-complete';

      // Toggle additional fields
      toggleAdditionalFieldsBtn.addEventListener('click', () => {
        additionalFieldsSection.classList.toggle('active');
        toggleAdditionalFieldsBtn.textContent = additionalFieldsSection.classList.contains('active')
          ? 'Hide Additional Configuration Fields'
          : 'Show Additional Configuration Fields';
      });

      // Load saved configuration if exists
      document.addEventListener('DOMContentLoaded', () => {
        // Load API key and payment method ID
        const savedApiKey = localStorage.getItem(API_KEY_STORAGE);
        if (savedApiKey) {
          apiKeyInput.value = savedApiKey;

          const savedPaymentMethodId = localStorage.getItem(PAYMENT_METHOD_ID_STORAGE);
          if (savedPaymentMethodId) {
            paymentMethodIdInput.value = savedPaymentMethodId;
          }
        }

        // Load additional fields
        const savedAmount = localStorage.getItem(AMOUNT_STORAGE);
        if (savedAmount) amountInput.value = savedAmount;

        // Load amount goods and services
        const savedAmountGoodsServices = localStorage.getItem(AMOUNT_GOODS_SERVICES_STORAGE);
        if (savedAmountGoodsServices) amountGoodsAndServicesInput.value = savedAmountGoodsServices;

        const savedTax = localStorage.getItem(TAX_STORAGE);
        if (savedTax) taxInput.value = savedTax;

        const savedCashBack = localStorage.getItem(CASHBACK_STORAGE);
        if (savedCashBack) cashBackInput.value = savedCashBack;

        const savedTip = localStorage.getItem(TIP_STORAGE);
        if (savedTip) tipInput.value = savedTip;

        const savedInvoiceNumber = localStorage.getItem(INVOICE_NUMBER_STORAGE);
        if (savedInvoiceNumber) invoiceNumberInput.value = savedInvoiceNumber;

        const savedOrderNumber = localStorage.getItem(ORDER_NUMBER_STORAGE);
        if (savedOrderNumber) orderNumberInput.value = savedOrderNumber;

        const savedReferenceId = localStorage.getItem(REFERENCE_ID_STORAGE);
        if (savedReferenceId) referenceIdInput.value = savedReferenceId;

        // Show success message if configuration is loaded
        if (savedApiKey) {
          showAlert(apiKeyStatus, 'Configuration loaded from local storage.', 'success');
        }

        // Load saved tokens and render them
        loadSavedTokens();

        // Set up webhook listening
        setupWebhookListener();
      });

      // Function to toggle blur on main container
      function toggleBlur(shouldBlur) {
        if (shouldBlur) {
          mainContainer.classList.add('blurred');
        } else {
          mainContainer.classList.remove('blurred');
        }
      }

      // Save configuration
      saveApiKeyBtn.addEventListener('click', () => {
        const apiKey = apiKeyInput.value.trim();
        const paymentMethodId = paymentMethodIdInput.value.trim();
        const amount = amountInput.value.trim();
        const amountGoodsAndServices = amountGoodsAndServicesInput.value.trim();
        const tax = taxInput.value.trim();
        const cashBack = cashBackInput.value.trim();
        const tip = tipInput.value.trim();
        const invoiceNumber = invoiceNumberInput.value.trim();
        const orderNumber = orderNumberInput.value.trim();
        const referenceId = referenceIdInput.value.trim();

        if (apiKey) {
          // Save required fields
          localStorage.setItem(API_KEY_STORAGE, apiKey);

          // Save or remove optional fields based on if they have values
          saveOrRemoveFromStorage(PAYMENT_METHOD_ID_STORAGE, paymentMethodId);
          saveOrRemoveFromStorage(AMOUNT_STORAGE, amount);
          saveOrRemoveFromStorage(AMOUNT_GOODS_SERVICES_STORAGE, amountGoodsAndServices);
          saveOrRemoveFromStorage(TAX_STORAGE, tax);
          saveOrRemoveFromStorage(CASHBACK_STORAGE, cashBack);
          saveOrRemoveFromStorage(TIP_STORAGE, tip);
          saveOrRemoveFromStorage(INVOICE_NUMBER_STORAGE, invoiceNumber);
          saveOrRemoveFromStorage(ORDER_NUMBER_STORAGE, orderNumber);
          saveOrRemoveFromStorage(REFERENCE_ID_STORAGE, referenceId);

          showAlert(apiKeyStatus, 'Configuration saved successfully!', 'success');
        } else {
          showAlert(apiKeyStatus, 'Please enter a valid API key.', 'error');
        }
      });
      // Test function to simulate a token webhook
      function simulateTokenWebhook() {
        // Create a sample token webhook payload
        const sampleToken = {
          id: 'pmt_tkn_' + Math.random().toString(36).substring(2, 12),
          cardType: 'VISA',
          maskedCardNumber: '************' + Math.floor(Math.random() * 9000 + 1000),
          cardExpDate: '12' + (new Date().getFullYear() + 2).toString().substring(2),
        };
        // Test function to process a production webhook
        function testProductionWebhook() {
          const productionWebhook = {
            eventData: {
              type: 'token.created',
              timestamp: '2025-05-16T17:17:23.9401063Z',
              id: 'evt_01JVD1KH34N5ZRPGQDVN9BFB12',
            },
            originalResponse: {
              id: 'trx_01JVD1JK6G3Z8G3R2J3VP37ZE8',
              resultCode: 0,
              resultText: 'Card successfully tokenized',
              referenceId: '2346345763465',
              amount: 200,
              paymentMethod: {
                id: 'pmt_vrt_01JVAYEP1MC8DM1CJMD000BRAD',
                type: 'Virtual',
                currency: 'USD',
              },
              transactionResponse: {
                authCode: '0000',
                cardType: 'MasterCard',
                accountType: 'Credit',
                responseCode: 1,
                paymentMethod: {
                  id: 'pmt_tkn_01JVD1KC3MVB15W6E0S5JTF1J0',
                  type: 'Token',
                  currency: 'USD',
                  cardType: 'Mastercard',
                  maskedCardNumber: '2****2815',
                  cardExpDate: '1225',
                },
                hostResponseText: 'APPROVED',
              },
            },
          };

          console.log('Testing with production webhook data:', productionWebhook);

          // First, try direct extraction
          const paymentMethod =
            productionWebhook.originalResponse?.transactionResponse?.paymentMethod;
          console.log('Direct extraction result:', paymentMethod);

          // Then run through normal processing
          processTokenEvent(productionWebhook);

          return paymentMethod;
        }
        // Save the token directly
        saveToken(sampleToken);

        // Reload the token display
        loadSavedTokens();

        console.log('Simulated token saved:', sampleToken);
        return sampleToken;
      }

      // Test function to process a production webhook
      function testProductionWebhook() {
        const productionWebhook = {
          eventData: {
            type: 'token.created',
            timestamp: '2025-05-16T17:17:23.9401063Z',
            id: 'evt_01JVD1KH34N5ZRPGQDVN9BFB12',
          },
          originalResponse: {
            id: 'trx_01JVD1JK6G3Z8G3R2J3VP37ZE8',
            resultCode: 0,
            resultText: 'Card successfully tokenized',
            referenceId: '2346345763465',
            amount: 200,
            paymentMethod: {
              id: 'pmt_vrt_01JVAYEP1MC8DM1CJMD000BRAD',
              type: 'Virtual',
              currency: 'USD',
            },
            transactionResponse: {
              authCode: '0000',
              cardType: 'MasterCard',
              accountType: 'Credit',
              responseCode: 1,
              paymentMethod: {
                id: 'pmt_tkn_01JVD1KC3MVB15W6E0S5JTF1J0',
                type: 'Token',
                currency: 'USD',
                cardType: 'Mastercard',
                maskedCardNumber: '2****2815',
                cardExpDate: '1225',
              },
              hostResponseText: 'APPROVED',
            },
          },
        };

        console.log('Testing with production webhook data:', productionWebhook);

        // First, try direct extraction
        const paymentMethod =
          productionWebhook.originalResponse?.transactionResponse?.paymentMethod;
        console.log('Direct extraction result:', paymentMethod);

        // Then run through normal processing
        processTokenEvent(productionWebhook);

        return paymentMethod;
      }
      // Helper function to save or remove item from localStorage
      function saveOrRemoveFromStorage(key, value) {
        if (value) {
          localStorage.setItem(key, value);
        } else {
          localStorage.removeItem(key);
        }
      }

      // Open modal to add new card
      addNewCardBtn.addEventListener('click', (e) => {
        e.preventDefault();

        // Reset modal state
        paymentIframe.style.display = 'none';
        apiError.style.display = 'none';
        spinner.style.display = 'block';

        // Display the modal
        cardModal.style.display = 'flex';

        // Apply blur to main container
        toggleBlur(true);

        // Call the API to create a payment session
        createCardNotPresentToken();
      });

      // Close modal when close button is clicked
      closeModalBtn.addEventListener('click', () => {
        cardModal.style.display = 'none';
        toggleBlur(false);
      });

      // Click outside modal to close (but not on the modal content)
      cardModal.addEventListener('click', (e) => {
        if (e.target === cardModal) {
          cardModal.style.display = 'none';
          toggleBlur(false);
        }
      });

      // Add escape key functionality
      document.addEventListener('keydown', function (event) {
        if (event.key === 'Escape' && cardModal.style.display === 'flex') {
          // Add visual feedback
          document.querySelector('.escape-instruction').style.color = '#c9a15f';

          // Reset after a short delay
          setTimeout(() => {
            cardModal.style.display = 'none';
            toggleBlur(false);
            // Reset color if the modal is opened again
            document.querySelector('.escape-instruction').style.color = '';
          }, 200);
        }
      });

      // Function to create a card not present token
      async function createCardNotPresentToken() {
        const apiKey = localStorage.getItem(API_KEY_STORAGE);

        // Always make sure to stop the spinner in case of errors
        try {
          if (!apiKey) {
            showAlert(apiError, 'API key is missing. Please enter and save your API key.', 'error');
            spinner.style.display = 'none';
            return;
          }

          // Generate a reference ID using current timestamp
          const referenceId = localStorage.getItem(REFERENCE_ID_STORAGE) || `ref_${Date.now()}`;

          // Check if the user has provided a payment method ID
          let paymentMethodId = localStorage.getItem(PAYMENT_METHOD_ID_STORAGE);

          console.log('Return URL:', RETURN_URL);

          // Prepare the request data
          const requestData = {
            referenceId: referenceId,
            returnUrl: RETURN_URL,
          };

          // Only add paymentMethodId to the request if we have one
          if (paymentMethodId) {
            requestData.paymentMethodId = paymentMethodId;
            console.log('Using payment method ID:', paymentMethodId);
          } else {
            console.log('Proceeding without a payment method ID');
          }

          console.log('Request payload:', JSON.stringify(requestData, null, 2));

          // Now create the token
          const endpoint = `${API_BASE_URL}/payment-methods/virtual`;
          console.log('Making request to:', endpoint);

          let response;
          try {
            response = await fetch(endpoint, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
              },
              body: JSON.stringify(requestData),
            });
          } catch (fetchError) {
            console.error('Network error during fetch:', fetchError);
            showAlert(apiError, `Network error: ${fetchError.message}`, 'error');
            spinner.style.display = 'none';
            return;
          }

          console.log('Response status:', response.status);

          // Get response text regardless of status
          let responseText = '';
          try {
            responseText = await response.text();
            console.log('Raw response:', responseText);
          } catch (e) {
            console.error('Could not read response body:', e);
            showAlert(apiError, 'Error reading API response', 'error');
            spinner.style.display = 'none';
            return;
          }

          // Try to parse as JSON if possible
          let data;
          try {
            if (responseText && responseText.trim() !== '') {
              data = JSON.parse(responseText);
            } else {
              showAlert(apiError, 'Empty response from API', 'error');
              spinner.style.display = 'none';
              return;
            }
          } catch (error) {
            console.error('Error parsing JSON response:', error);
            showAlert(
              apiError,
              `Invalid JSON response: ${responseText.substring(0, 100)}...`,
              'error'
            );
            spinner.style.display = 'none';
            return;
          }

          // Check if response was successful
          if (!response.ok) {
            let errorMessage = 'API request failed';

            if (data && data.error && data.error.message) {
              errorMessage = data.error.message;
            } else if (data && data.message) {
              errorMessage = data.message;
            } else {
              errorMessage = `Error ${response.status}: ${response.statusText}`;
            }

            console.error('API error:', errorMessage);
            showAlert(apiError, errorMessage, 'error');
            spinner.style.display = 'none';
            return;
          }

          // Handle successful response with missing data
          if (!data) {
            showAlert(apiError, 'Empty response from API', 'error');
            spinner.style.display = 'none';
            return;
          }

          console.log('API response data:', data);

          // Process the iframe URL if available
          if (data.iframeUrl) {
            // Create and add stylesheet to the document to ensure iframe content has no scrollbars
            const style = document.createElement('style');
            style.textContent = `
          iframe.iframe-container {
            overflow: hidden !important;
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
          }
          iframe.iframe-container::-webkit-scrollbar {
            display: none !important;
            width: 0 !important;
            height: 0 !important;
          }
        `;
            document.head.appendChild(style);

            // Update iframe source and display it
            paymentIframe.src = data.iframeUrl;
            paymentIframe.style.display = 'block';
            spinner.style.display = 'none'; // Hide spinner when iframe is shown
          } else {
            // Handle missing iframe URL
            let errorMsg = 'Failed to create payment session. No iframe URL returned.';
            if (data.error && data.error.message) {
              errorMsg = data.error.message;
            } else if (data.message) {
              errorMsg = data.message;
            }
            showAlert(apiError, errorMsg, 'error');
            spinner.style.display = 'none';
          }
        } catch (error) {
          // Catch-all error handler to ensure spinner is always hidden
          console.error('Unhandled error in payment processing:', error);
          showAlert(apiError, `Unexpected error: ${error.message}`, 'error');
          spinner.style.display = 'none';
        }
      }

      // Process a virtual (Card Not Present) sale
      async function processVirtualSale() {
        const apiKey = localStorage.getItem(API_KEY_STORAGE);

        if (!apiKey) {
          alert('API key is missing. Please enter and save your API key.');
          return;
        }

        // Generate a reference ID using current timestamp or use saved one
        const referenceId = localStorage.getItem(REFERENCE_ID_STORAGE) || `ref_${Date.now()}`;

        // Get payment method ID if available
        const paymentMethodId = localStorage.getItem(PAYMENT_METHOD_ID_STORAGE);

        // Get other configuration values
        const amount = parseInt(localStorage.getItem(AMOUNT_STORAGE) || '7273');
        const tax = parseInt(localStorage.getItem(TAX_STORAGE) || '0');
        const cashBack = parseInt(localStorage.getItem(CASHBACK_STORAGE) || '0');
        const tip = parseInt(localStorage.getItem(TIP_STORAGE) || '0');
        const invoiceNumber = localStorage.getItem(INVOICE_NUMBER_STORAGE) || `inv_${Date.now()}`;
        const orderNumber = localStorage.getItem(ORDER_NUMBER_STORAGE) || `ord_${Date.now()}`;

        // Reset modal state
        paymentIframe.style.display = 'none';
        apiError.style.display = 'none';
        spinner.style.display = 'block';

        // Display the modal for processing payment
        cardModal.style.display = 'flex';
        toggleBlur(true);

        try {
          // Prepare request data
          const requestData = {
            referenceId: referenceId,
            returnUrl: RETURN_URL,
            amount: amount,
            amountBreakdown: {
              tax: tax,
              cashBack: cashBack,
              tip: tip,
            },
            invoiceNumber: invoiceNumber,
            orderNumber: orderNumber,
          };

          // Add payment method ID if available
          if (paymentMethodId) {
            requestData.paymentMethodId = paymentMethodId;
          }

          console.log('Virtual sale request:', JSON.stringify(requestData, null, 2));

          // Make the API request
          const endpoint = `${API_BASE_URL}/transactions/virtual-sale`;

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'x-api-key': apiKey,
            },
            body: JSON.stringify(requestData),
          });

          // Parse the response
          const responseText = await response.text();
          let data;

          try {
            if (responseText && responseText.trim() !== '') {
              data = JSON.parse(responseText);
            } else {
              throw new Error('Empty response');
            }
          } catch (error) {
            console.error('Error parsing response:', error);
            showAlert(apiError, 'Invalid response format', 'error');
            spinner.style.display = 'none';
            return;
          }

          // Handle error response
          if (!response.ok) {
            let errorMessage = 'Payment processing failed';

            if (data && data.error && data.error.message) {
              errorMessage = data.error.message;
            } else if (data && data.message) {
              errorMessage = data.message;
            } else {
              errorMessage = `Error ${response.status}: ${response.statusText}`;
            }

            console.error('API error:', errorMessage);
            showAlert(apiError, errorMessage, 'error');
            spinner.style.display = 'none';
            return;
          }

          // Handle iframe URL if available
          if (data.iframeUrl) {
            // Update iframe source and display it
            paymentIframe.src = data.iframeUrl;
            paymentIframe.style.display = 'block';
            spinner.style.display = 'none';
          } else {
            // Handle missing iframe URL
            showAlert(apiError, 'No payment iframe URL returned', 'error');
            spinner.style.display = 'none';
          }
        } catch (error) {
          console.error('Error processing virtual sale:', error);
          showAlert(apiError, `Payment processing error: ${error.message}`, 'error');
          spinner.style.display = 'none';
        }
      }

      // Complete updated processTokenSale function with enhanced debugging and error handling
      async function processTokenSale(tokenId) {
        const apiKey = localStorage.getItem(API_KEY_STORAGE);

        if (!apiKey) {
          alert('API key is missing. Please enter and save your API key.');
          return;
        }

        if (!tokenId) {
          alert('Please select a payment method first.');
          return;
        }

        // Get configuration values
        const referenceId = localStorage.getItem(REFERENCE_ID_STORAGE) || `ref_${Date.now()}`;
        const amount = parseInt(localStorage.getItem(AMOUNT_STORAGE) || '7273');
        const tax = parseInt(localStorage.getItem(TAX_STORAGE) || '0');
        const cashBack = parseInt(localStorage.getItem(CASHBACK_STORAGE) || '0');
        const tip = parseInt(localStorage.getItem(TIP_STORAGE) || '0');
        const invoiceNumber = localStorage.getItem(INVOICE_NUMBER_STORAGE) || `inv_${Date.now()}`;
        const orderNumber = localStorage.getItem(ORDER_NUMBER_STORAGE) || `ord_${Date.now()}`;

        // Get or calculate amount goods and services
        let amountGoodsAndServices = parseInt(
          localStorage.getItem(AMOUNT_GOODS_SERVICES_STORAGE) || '0'
        );

        // If amount goods and services isn't explicitly set, calculate it from the total amount
        if (!amountGoodsAndServices) {
          amountGoodsAndServices = amount - (tax + cashBack + tip);
        }

        try {
          // Show loading state
          const originalButtonText = checkoutExistingBtn.textContent;
          checkoutExistingBtn.textContent = 'Processing...';
          checkoutExistingBtn.disabled = true;

          // Prepare request data
          const requestData = {
            referenceId: referenceId,
            paymentMethodId: tokenId, // Using paymentMethodId instead of tokenId
            amount: amount,
            amountBreakdown: {
              tax: tax,
              cashBack: cashBack,
              tip: tip,
              amountGoodsAndServices: amountGoodsAndServices, // Using the explicit or calculated value
            },
            invoiceNumber: invoiceNumber,
            orderNumber: orderNumber,
          };

          console.log('Token sale request:', JSON.stringify(requestData, null, 2));

          // Make the API request
          const endpoint = `${API_BASE_URL}/transactions/token-sale`;
          const headers = {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
          };
          const body = JSON.stringify(requestData);

          // Log request details for debugging
          console.group('API Request Details');
          console.log('Endpoint:', endpoint);
          console.log('Method: POST');
          console.log('Headers:', headers);
          console.log('Request Body:', body);
          try {
            console.log('Request Body (parsed):', JSON.parse(body));
          } catch (e) {
            console.log('Could not parse request body as JSON');
          }
          console.groupEnd();

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: headers,
            body: body,
          });

          // Parse the response
          const responseText = await response.text();
          console.log('Raw API Response:', responseText);

          let data;
          try {
            if (responseText && responseText.trim() !== '') {
              data = JSON.parse(responseText);
              console.log('Parsed API Response:', data);
            } else {
              throw new Error('Empty response');
            }
          } catch (error) {
            console.error('Error parsing response:', error);
            alert(`Error: Invalid response format\n\nRaw response: ${responseText}`);
            checkoutExistingBtn.textContent = originalButtonText;
            checkoutExistingBtn.disabled = false;
            return;
          }

          // Handle error response
          if (!response.ok) {
            console.error('API Error Response Status:', response.status);
            console.error('API Error Raw Response:', responseText);

            try {
              // Try to format the JSON response for display
              const formattedJson = JSON.stringify(data, null, 2);
              console.error('API Error Formatted JSON:', formattedJson);

              // Show the complete error response in an alert
              alert(
                `Error: API returned an error.\n\nStatus: ${response.status}\n\nRaw Response:\n${responseText}\n\nFormatted JSON:\n${formattedJson}`
              );
            } catch (e) {
              // If JSON formatting fails, show the raw response
              alert(
                `Error: API returned an error.\n\nStatus: ${response.status}\n\nRaw Response:\n${responseText}`
              );
            }

            checkoutExistingBtn.textContent = originalButtonText;
            checkoutExistingBtn.disabled = false;
            return;
          }

          // Handle successful response
          console.log('Payment successful:', data);

          // Redirect to payment complete page with transaction details
          const params = new URLSearchParams();
          params.append('resultCode', data.resultCode || '0');
          params.append('transactionId', data.id || 'unknown');
          params.append('amount', amount.toString());

          window.location.href = `${RETURN_URL}?${params.toString()}`;
        } catch (error) {
          console.error('Error processing token sale:', error);
          alert(`Payment processing error: ${error.message}\n\nStack trace: ${error.stack}`);

          // Reset button state
          checkoutExistingBtn.textContent = 'Complete Checkout with Selected Payment Method';
          checkoutExistingBtn.disabled = false;
        }
      }

      // Set up event listener for iframe postMessages
      function setupIframeMessageListener() {
        window.addEventListener('message', (event) => {
          // Verify origin for security
          if (
            event.origin.includes('fiska.tech') ||
            event.origin.includes('integratedcommerce.io')
          ) {
            try {
              const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

              // Handle resize events from the iframe
              if (data.action === 'resize') {
                // If iframe sends a resize message, adjust modal height
                if (data.height) {
                  const modal = document.querySelector('.modal');
                  modal.style.height = `${data.height}px`;
                }
              }

              if (data.status === 'completed') {
                // Payment was successful
                cardModal.style.display = 'none';
                toggleBlur(false);

                // Handle payment transaction completion
                if (data.transactionId) {
                  // Redirect to payment complete page with result
                  const params = new URLSearchParams();
                  params.append('resultCode', '0');
                  params.append('transactionId', data.transactionId);

                  if (data.amount) {
                    params.append('amount', data.amount.toString());
                  }

                  window.location.href = `${RETURN_URL}?${params.toString()}`;
                } else {
                  // Just a token creation, not a payment
                  const cardDetails = data.cardDetails || {};

                  // Show success message
                  alert('Payment method added successfully!');
                }
              } else if (data.status === 'error') {
                // Payment failed
                showAlert(apiError, data.message || 'Payment failed. Please try again.', 'error');
              } else if (data.status === 'canceled') {
                // User canceled the payment
                cardModal.style.display = 'none';
                toggleBlur(false);
              }
            } catch (error) {
              console.error('Error processing postMessage:', error);
            }
          }
        });
      }

      // Setup iframe message listener on load
      setupIframeMessageListener();

      // Set up webhook listener to capture token events
      function setupWebhookListener() {
        // Check for token.created events in localStorage periodically
        // In a real implementation, this would use websockets or server-sent events
        setInterval(checkForNewTokens, 5000);

        // Initial check
        checkForNewTokens();
      }

      // Check local storage for webhooks with token.created events
      function checkForNewTokens() {
        const storedWebhooks = JSON.parse(localStorage.getItem('webhookLog') || '[]');
        console.log('Checking for new tokens among', storedWebhooks.length, 'webhooks');

        // Find token.created events
        for (const webhook of storedWebhooks) {
          // Try to determine if this is a token event
          let isTokenEvent = false;
          let webhookType = '';

          // Check webhook.type
          if (webhook.type === 'token.created') {
            isTokenEvent = true;
            webhookType = webhook.type;
          }
          // Check webhook.event.type
          else if (webhook.event && webhook.event.type === 'token.created') {
            isTokenEvent = true;
            webhookType = webhook.event.type;
          }
          // Check webhook.payload.event.type
          else if (
            webhook.payload &&
            webhook.payload.event &&
            webhook.payload.event.type === 'token.created'
          ) {
            isTokenEvent = true;
            webhookType = webhook.payload.event.type;
          }
          // Check webhook.data.event.type
          else if (
            webhook.data &&
            webhook.data.event &&
            webhook.data.event.type === 'token.created'
          ) {
            isTokenEvent = true;
            webhookType = webhook.data.event.type;
          }

          if (isTokenEvent) {
            console.log('Found token event:', webhookType);
            processTokenEvent(webhook);
          }
        }
      }

      // Process a token event and extract the token information
      function processTokenEvent(event) {
        try {
          console.log('Processing token event:', event);

          // Extract token information - field structure might vary
          let paymentMethod = null;

          // Build a list of places to look for the payment method
          const possiblePaths = [
            // Direct paths (array format)
            event.originalResponse?.transactionResponses?.[0]?.paymentMethod,
            event.payload?.originalResponse?.transactionResponses?.[0]?.paymentMethod,
            event.data?.originalResponse?.transactionResponses?.[0]?.paymentMethod,

            // Singular format
            event.originalResponse?.transactionResponse?.paymentMethod,
            event.payload?.originalResponse?.transactionResponse?.paymentMethod,
            event.data?.originalResponse?.transactionResponse?.paymentMethod,

            // Additional paths
            event.tokenInfo,
            event.payload?.tokenInfo,
            event.data?.tokenInfo,
          ];

          // Log detailed path information for debugging
          console.log('Checking possible paths for token:', {
            'event.originalResponse?.transactionResponse?.paymentMethod':
              event.originalResponse?.transactionResponse?.paymentMethod,
            'event.data?.originalResponse?.transactionResponse?.paymentMethod':
              event.data?.originalResponse?.transactionResponse?.paymentMethod,
          });

          // Try each path
          for (const path of possiblePaths) {
            if (path && path.id) {
              paymentMethod = path;
              break;
            }
          }

          // If still not found, do a deep search
          if (!paymentMethod) {
            console.log('Payment method not found in common paths, doing deep search');
            paymentMethod = findPaymentMethod(event);
          }

          if (!paymentMethod || !paymentMethod.id) {
            console.warn('Could not extract payment method from event:', event);
            return;
          }

          console.log('Found payment method:', paymentMethod);

          // Create token object
          const token = {
            id: paymentMethod.id,
            cardType: paymentMethod.cardType || 'Card',
            maskedCardNumber: paymentMethod.maskedCardNumber || '************0000',
            cardExpDate: paymentMethod.cardExpDate || '0000',
            timestamp: new Date().toISOString(),
          };

          // Save token to storage
          saveToken(token);

          // Update UI
          loadSavedTokens();

          console.log('Token saved:', token);
        } catch (error) {
          console.error('Error processing token event:', error);
        }
      }

      // Add this deep search function to find the payment method in any nested structure
      function findPaymentMethod(obj, depth = 0) {
        // Prevent infinite recursion
        if (depth > 10) return null;

        // If not an object or null, return
        if (!obj || typeof obj !== 'object') return null;

        // Check if this object has the required properties to be a payment method
        if (obj.id && (obj.type === 'token' || obj.maskedCardNumber)) {
          return obj;
        }

        // Search in arrays
        if (Array.isArray(obj)) {
          for (const item of obj) {
            const result = findPaymentMethod(item, depth + 1);
            if (result) return result;
          }
          return null;
        }

        // Search in object properties
        for (const key of Object.keys(obj)) {
          // Skip some common properties that are unlikely to contain payment methods
          if (key === 'type' || key === 'timestamp') continue;

          const result = findPaymentMethod(obj[key], depth + 1);
          if (result) return result;
        }

        return null;
      }
      // Save a token to local storage
      function saveToken(token) {
        // Get existing tokens
        const tokens = JSON.parse(localStorage.getItem(TOKEN_STORAGE) || '[]');

        // Check if token already exists
        const existingTokenIndex = tokens.findIndex((t) => t.id === token.id);

        if (existingTokenIndex !== -1) {
          // Update existing token
          tokens[existingTokenIndex] = token;
        } else {
          // Add new token
          tokens.unshift(token);

          // Keep only the last 3 tokens
          if (tokens.length > 3) {
            tokens.length = 3;
          }
        }

        // Save back to storage
        localStorage.setItem(TOKEN_STORAGE, JSON.stringify(tokens));
      }

      // Load saved tokens from local storage
      function loadSavedTokens() {
        const tokens = JSON.parse(localStorage.getItem(TOKEN_STORAGE) || '[]');

        // Clear container
        savedCardsContainer.innerHTML = '';

        if (tokens.length === 0) {
          // Show no tokens message
          savedCardsContainer.innerHTML = `
      <div class="no-tokens-message" id="noTokensMessage">
        No saved payment methods available. You can add a new card or use stored tokens from webhooks.
      </div>
      `;
          return;
        }

        // Display each token
        tokens.forEach((token, index) => {
          // Format expiration date if needed (MMYY format)
          let expMonth = '';
          let expYear = '';

          if (token.cardExpDate && token.cardExpDate.length === 4) {
            expMonth = token.cardExpDate.substring(0, 2);
            expYear = token.cardExpDate.substring(2);
          }

          const cardElement = document.createElement('div');
          cardElement.className = 'payment-method';
          cardElement.innerHTML = `
      <input type="radio" name="paymentMethod" id="token${index}" value="${token.id}" ${index === 0 ? 'checked' : ''}>
      <div class="payment-method-info">
        <div>${token.cardType || 'Card'} ${token.maskedCardNumber || '************0000'}</div>
        <div style="color: var(--color-text-light);">Expires ${expMonth || '00'}/${expYear || '00'}</div>
        <div style="color: var(--color-text-light); font-size: 0.85rem;">Token ID: ${token.id}</div>
      </div>
      `;

          savedCardsContainer.appendChild(cardElement);
        });

        // Add enhanced logging
        console.log(
          'Current tokens in storage:',
          JSON.parse(localStorage.getItem(TOKEN_STORAGE) || '[]')
        );
      }

      // Helper function to show alerts
      function showAlert(element, message, type) {
        element.textContent = message;
        element.style.display = 'block';

        if (type === 'error') {
          element.className = 'alert alert-error';
        } else {
          element.className = 'alert alert-success';
        }

        // Auto-hide after 5 seconds
        setTimeout(() => {
          element.style.display = 'none';
        }, 5000);
      }

      // Update the checkoutExistingBtn click handler to prompt for token ID
      checkoutExistingBtn.addEventListener('click', () => {
        // Prompt for token ID
        const tokenId = prompt('Enter Payment Method ID (Token ID):', '');

        // Validate input
        if (tokenId === null) {
          // User canceled the prompt
          return;
        }

        if (!tokenId.trim()) {
          alert('Please enter a valid Payment Method ID');
          return;
        }

        // Process the sale with the provided token
        processTokenSale(tokenId.trim());
      });

      // Update the button text to reflect the new functionality
      checkoutExistingBtn.textContent = 'Complete Checkout with Token ID';

      checkoutNewBtn.addEventListener('click', () => {
        processVirtualSale();
      });
      // Event listeners for token refresh and simulation
      document.getElementById('refreshTokensBtn').addEventListener('click', (e) => {
        e.preventDefault();
        checkForNewTokens();
        loadSavedTokens();
      });

      document.getElementById('simulateTokenBtn').addEventListener('click', (e) => {
        e.preventDefault();
        simulateTokenWebhook();
      });

      // Add this new event listener
      document.getElementById('simulateProductionBtn').addEventListener('click', (e) => {
        e.preventDefault();
        testProductionWebhook();
      });

      // Test webhook processing - simulates receiving a token.created webhook
      // This function is just for testing purposes
      window.processTestWebhook = function (type = 'token.created') {
        const webhook = {
          type: type,
          event: { type: type },
          originalResponse: {
            transactionResponses: [
              {
                paymentMethod: {
                  id: 'pmt_tkn_' + Math.random().toString(36).substring(2, 12),
                  cardType: 'VISA',
                  maskedCardNumber: '************' + Math.floor(Math.random() * 9000 + 1000),
                  cardExpDate: '12' + (new Date().getFullYear() + 2).toString().substring(2),
                },
              },
            ],
          },
        };

        processTokenEvent(webhook);
        return webhook;
      };
    </script>
  </body>
</html>
